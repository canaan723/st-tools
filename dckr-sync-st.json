[{"name":"酒馆GIT【恢复】","type":"shell","groupID":7,"specCustom":false,"spec":"30 1 3 * *","executor":"bash","scriptMode":"input","script":"#!/usr/bin/env bash\n\n# SillyTavern 1Panel 同步脚本 v1.0\n# 作者: Qingjue | 小红书号: 826702880\n#\n# 该脚本用于将 SillyTavern 的用户数据与一个远程 Git 仓库进行同步。\n# 支持上传（本地 -\u003e 远程）和恢复（远程 -\u003e 本地）两种模式。\n\n# --- 核心操作定义 ---\n# \"up\"   代表上传本地数据到云端\n# \"down\" 代表从云端恢复数据到本地\nACTION=\"down\"\n\n# --- 脚本基础设置 ---\n# 任何命令执行失败或管道失败时立即退出脚本\nset -e\nset -o pipefail\n\n# --- 全局常量 ---\n# 用于日志输出的颜色代码\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nRED='\\033[0;31m'\nNC='\\033[0m'\nCYAN='\\033[0;36m'\n\n# SillyTavern 顶层系统文件夹，用于在同步时排除\nreadonly TOP_LEVEL_SYSTEM_FOLDERS=(\"data/_storage\" \"data/_cache\" \"data/_uploads\" \"data/_webpack\")\n\n# --- 全局变量 ---\n# 脚本运行时动态填充的变量\nST_DIR=\"\"\nREPO_URL=\"\"\nREPO_TOKEN=\"\"\nSYNC_CONFIG_YAML=\"\"\nUSER_MAP=\"\"\nEXCLUDE_USERS=\"\"\nENABLE_MIRRORS=\"false\"\nMIRROR_LIST=()\n\n# 用于生成任务摘要的变量\nSUMMARY_ACTION_TYPE=\"\"\nSUMMARY_TARGET_REPO=\"\"\nSUMMARY_MIRROR_USED=\"\"\nSUMMARY_USERS_PROCESSED=()\nSUMMARY_CONFIG_SYNCED=\"否\"\nSUMMARY_USER_MAP_APPLIED=\"无\"\nSUMMARY_EXCLUDES_APPLIED=\"无\"\n\n# --- 日志函数 ---\nlog_info() { echo -e \"${GREEN}[信息] $1${NC}\"; }\nlog_warn() { echo -e \"${YELLOW}[警告] $1${NC}\"; }\nlog_error() { echo -e \"\\n${RED}[错误] $1${NC}\\n\"; exit 1; }\n\n# --- 辅助函数 ---\n\n# 获取 SillyTavern/data 目录下的所有非系统用户文件夹\nfn_get_user_folders() {\n    local target_dir=\"$1\"\n    if [[ ! -d \"$target_dir\" ]]; then return; fi\n\n    mapfile -t all_subdirs \u003c \u003c(find \"$target_dir\" -mindepth 1 -maxdepth 1 -type d -exec basename {} \\;)\n    local user_folders=()\n    for dir in \"${all_subdirs[@]}\"; do\n        local is_system_folder=false\n        for sys_folder in \"${TOP_LEVEL_SYSTEM_FOLDERS[@]}\"; do\n            if [[ \"data/$dir\" == \"$sys_folder\" ]]; then\n                is_system_folder=true\n                break\n            fi\n        done\n        if [[ \"$is_system_folder\" == false ]]; then\n            user_folders+=(\"$dir\")\n        fi\n    done\n    echo \"${user_folders[@]}\"\n}\n\n# 自动查找并加载配置文件，同时推导 SillyTavern 的根目录\nfn_setup_paths_and_load_config() {\n    log_info \"正在智能搜索配置文件 (git_sync.conf)...\"\n    local config_file\n    config_file=$(find /root /home /opt -maxdepth 5 -type f -name \"git_sync.conf\" 2\u003e/dev/null | head -n 1)\n    if [[ -z \"$config_file\" ]]; then\n        log_error \"未能找到 'git_sync.conf' 配置文件。\\n请确保在 SillyTavern 项目目录内创建了 '.config/git_sync.conf' 文件。\"\n    fi\n    log_info \"已找到同步配置文件: $config_file\"\n\n    local config_dir\n    config_dir=$(dirname \"$config_file\")\n    ST_DIR=$(dirname \"$config_dir\")\n\n    if [[ ! -d \"$ST_DIR\" ]] || [[ ! -f \"${ST_DIR}/docker-compose.yml\" ]]; then\n        log_error \"根据配置文件推导出的 SillyTavern 目录 '$ST_DIR' 无效。\\n请检查 'git_sync.conf' 的存放位置是否正确。\"\n    fi\n    log_info \"已自动推导 SillyTavern 目录为: ${ST_DIR}\"\n\n    # 加载主配置文件\n    # shellcheck source=/dev/null\n    source \"$config_file\"\n    SUMMARY_TARGET_REPO=\"$REPO_URL\"\n    if [[ -z \"$REPO_URL\" ]] || [[ -z \"$REPO_TOKEN\" ]]; then\n        log_error \"配置文件 'git_sync.conf' 不完整！请确保已设置 REPO_URL 和 REPO_TOKEN。\"\n    fi\n\n    # 加载可选的同步规则和网络配置文件\n    local sync_rules_config=\"${config_dir}/sync_rules.conf\"\n    if [[ -f \"$sync_rules_config\" ]]; then\n        log_info \"已找到同步规则文件: $sync_rules_config\"\n        # shellcheck source=/dev/null\n        source \"$sync_rules_config\"\n    fi\n\n    local network_config=\"${config_dir}/network.conf\"\n    if [[ -f \"$network_config\" ]]; then\n        log_info \"已找到网络配置文件: $network_config\"\n        # shellcheck source=/dev/null\n        source \"$network_config\"\n    fi\n    log_info \"配置加载成功！镜像加速: ${ENABLE_MIRRORS}\"\n}\n\n# 检查脚本运行所需的核心依赖（git, rsync, zip）并尝试自动安装\nfn_check_deps() {\n    log_info \"正在检查核心依赖 (git, rsync, zip)...\"\n    local missing_pkgs=()\n    for pkg in git rsync zip; do\n        if ! command -v \"$pkg\" \u0026\u003e/dev/null; then\n            missing_pkgs+=(\"$pkg\")\n        fi\n    done\n\n    if [[ ${#missing_pkgs[@]} -gt 0 ]]; then\n        log_warn \"检测到核心依赖缺失: ${missing_pkgs[*]}. 正在尝试自动安装...\"\n        if apt-get update -y \u0026\u0026 apt-get install -y \"${missing_pkgs[@]}\"; then\n            log_info \"核心依赖已自动安装成功！\"\n        else\n            log_error \"自动安装依赖失败！\\n请手动执行命令: apt-get update \u0026\u0026 apt-get install -y ${missing_pkgs[*]}\"\n        fi\n    else\n        log_info \"核心依赖完整。\"\n    fi\n}\n\n# 根据镜像地址和仓库地址，构造包含认证信息的 Git URL\nfn_construct_authed_url() {\n    local mirror_base_url=\"$1\"\n    local repo_path\n    repo_path=$(echo \"$REPO_URL\" | sed 's|https://github.com/||')\n\n    case \"$mirror_base_url\" in\n        *\"github.com\"*)\n            echo \"https://${REPO_TOKEN}@github.com/${repo_path}\" ;;\n        *\"hub.gitmirror.com\"*)\n            echo \"https://${REPO_TOKEN}@hub.gitmirror.com/${repo_path}\" ;;\n        *\"/gh\")\n            local domain\n            domain=$(echo \"$mirror_base_url\" | sed -e 's|https://||' -e 's|/.*$||')\n            echo \"https://${REPO_TOKEN}@${domain}/gh/${repo_path}\" ;;\n        *\"gh-proxy.com\"*|*\"gh.llkk.cc\"*|*\"tvv.tw\"*|*\"proxy.pipers.cn\"*|*\"gh.catmak.name\"*|*\"gh-proxy.net\"*)\n            echo \"${mirror_base_url}/https://${REPO_TOKEN}@github.com/${repo_path}\" ;;\n        *)\n            return 1 ;;\n    esac\n}\n\n# 扫描并输出所有已安装的全局扩展和用户扩展的 Git 仓库地址\nfn_export_extension_links() {\n    local all_links_output=\"\"\n    local global_ext_path=\"$ST_DIR/public/scripts/extensions/third-party\"\n\n    if [[ -d \"$global_ext_path\" ]]; then\n        local global_links\n        global_links=$(\n            find \"$global_ext_path\" -mindepth 1 -maxdepth 1 -type d | while read -r ext_dir; do\n                if [[ -d \"$ext_dir/.git\" ]]; then\n                    git -C \"$ext_dir\" config --get remote.origin.url 2\u003e/dev/null\n                fi\n            done\n        )\n        if [[ -n \"$global_links\" ]]; then\n            all_links_output+=\"═══ 全局扩展 ═══\\n${global_links}\\n\"\n        fi\n    fi\n\n    local user_folders\n    user_folders=($(fn_get_user_folders \"$ST_DIR/data\"))\n    for user in \"${user_folders[@]}\"; do\n        local user_ext_path=\"$ST_DIR/data/$user/extensions\"\n        if [[ -d \"$user_ext_path\" ]]; then\n            local user_links\n            user_links=$(\n                find \"$user_ext_path\" -mindepth 1 -maxdepth 1 -type d | while read -r ext_dir; do\n                    if [[ -d \"$ext_dir/.git\" ]]; then\n                        git -C \"$ext_dir\" config --get remote.origin.url 2\u003e/dev/null\n                    fi\n                done\n            )\n            if [[ -n \"$user_links\" ]]; then\n                all_links_output+=\"\\n═══ 用户 [${user}] 的扩展 ═══\\n${user_links}\"\n            fi\n        fi\n    done\n\n    if [[ -n \"$all_links_output\" ]]; then\n        echo -e \"${CYAN}─────────────────── 已安装扩展链接 ───────────────────${NC}\"\n        printf \"%b\" \"${CYAN}${all_links_output}${NC}\\n\"\n        echo -e \"${CYAN}──────────────────────────────────────────────────────${NC}\"\n    fi\n}\n\n# 在任务结束时打印本次同步的摘要信息\nfn_print_summary() {\n    echo -e \"${CYAN}──────────────────── 同步任务摘要 ────────────────────${NC}\"\n    echo -e \"${CYAN}任务类型        : ${SUMMARY_ACTION_TYPE}${NC}\"\n    echo -e \"${CYAN}目标仓库        : ${SUMMARY_TARGET_REPO}${NC}\"\n    echo -e \"${CYAN}实际使用线路    : ${SUMMARY_MIRROR_USED}${NC}\"\n    echo -e \"${CYAN}──────────────────────────────────────────────────────${NC}\"\n    if [[ ${#SUMMARY_USERS_PROCESSED[@]} -gt 0 ]]; then\n        echo -e \"${CYAN}同步的用户文件夹: ${SUMMARY_USERS_PROCESSED[*]}${NC}\"\n    else\n        echo -e \"${CYAN}同步的用户文件夹: 无${NC}\"\n    fi\n    echo -e \"${CYAN}同步 config.yaml  : ${SUMMARY_CONFIG_SYNCED}${NC}\"\n    echo -e \"${CYAN}────────────────────── 应用规则 ──────────────────────${NC}\"\n    echo -e \"${CYAN}用户映射规则    : ${SUMMARY_USER_MAP_APPLIED}${NC}\"\n    if [[ \"$SUMMARY_ACTION_TYPE\" == \"恢复\" ]]; then\n      echo -e \"${CYAN}排除的云端用户  : ${SUMMARY_EXCLUDES_APPLIED}${NC}\"\n    fi\n    echo -e \"${CYAN}──────────────────────────────────────────────────────${NC}\"\n}\n\n# 创建一个本地的用户数据备份压缩包\nfn_backup_local() {\n    local backup_type=\"$1\"\n    local backup_root_dir=\"${ST_DIR}/_SillyTavern_Backups\"\n    mkdir -p \"$backup_root_dir\"\n    log_info \"正在触发“${backup_type}”类型的本地备份...\"\n\n    local timestamp\n    timestamp=$(date +\"%Y-%m-%d_%H-%M\")\n    local backup_zip_path=\"${backup_root_dir}/ST_备份_${backup_type}_${timestamp}.zip\"\n\n    local paths_to_zip=()\n    local user_folders\n    user_folders=($(fn_get_user_folders \"$ST_DIR/data\"))\n    for user in \"${user_folders[@]}\"; do\n        paths_to_zip+=(\"data/$user\")\n    done\n\n    if [[ \"$SYNC_CONFIG_YAML\" == \"true\" ]] \u0026\u0026 [[ -f \"$ST_DIR/config.yaml\" ]]; then\n        paths_to_zip+=(\"config.yaml\")\n    fi\n\n    if [[ ${#paths_to_zip[@]} -eq 0 ]]; then\n        log_warn \"未找到任何可备份的用户数据，已跳过本地备份。\"\n        return\n    fi\n\n    log_info \"正在压缩文件到: ${backup_zip_path}\"\n    # 在 ST_DIR 目录内执行 zip 命令，以保持压缩包内的目录结构正确\n    if (cd \"$ST_DIR\" \u0026\u0026 zip -rq \"$backup_zip_path\" \"${paths_to_zip[@]}\" --exclude \"*/extensions/*\" --exclude \"*/backups/*\" --exclude \"*.log\"); then\n        log_info \"创建本地备份成功。\"\n    else\n        log_error \"创建本地备份失败！\"\n    fi\n}\n\n# --- 核心同步逻辑 ---\n\n# 执行上传操作：将本地数据同步到远程 Git 仓库\nfn_sync_up() {\n    SUMMARY_ACTION_TYPE=\"上传\"\n    log_info \"开始执行 [${SUMMARY_ACTION_TYPE}] 任务。\"\n    local temp_dir\n    temp_dir=$(mktemp -d)\n    trap 'rm -rf \"$temp_dir\"' EXIT\n\n    # 步骤 1: 克隆远程仓库到临时目录\n    local full_mirror_list=(\"https://github.com\")\n    if [[ \"$ENABLE_MIRRORS\" == \"true\" ]]; then\n        full_mirror_list+=(\"${MIRROR_LIST[@]}\")\n    fi\n\n    local clone_success=false\n    for mirror_url in \"${full_mirror_list[@]}\"; do\n        local authed_clone_url\n        authed_clone_url=$(fn_construct_authed_url \"$mirror_url\") || continue\n        local host\n        host=$(echo \"$mirror_url\" | sed -e 's|https://||' -e 's|/.*$||')\n        log_info \"步骤 1/5: 正在尝试使用线路 [${host}] 克隆仓库...\"\n        if git clone -q --depth 1 \"$authed_clone_url\" \"$temp_dir\"; then\n            clone_success=true\n            SUMMARY_MIRROR_USED=\"$host\"\n            log_info \"    ${GREEN}[成功] 克隆成功。${NC}\"\n            break\n        else\n            log_warn \"    ${YELLOW}[失败] 使用线路 [${host}] 克隆失败，正在切换...${NC}\"\n        fi\n    done\n    if [[ \"$clone_success\" == false ]]; then\n        log_error \"已尝试所有可用线路，但克隆云端仓库均失败。\"\n    fi\n\n    # 定义 rsync 排除参数，使用数组以避免参数分割问题\n    local rsync_exclude_args=('--exclude=extensions/' '--exclude=backups/' '--exclude=*.log')\n\n    # 步骤 2: 将本地数据同步到临时目录\n    log_info \"步骤 2/5: 同步本地用户数据...\"\n    if [[ -n \"$USER_MAP\" ]] \u0026\u0026 [[ \"$USER_MAP\" == *\":\"* ]]; then\n        local local_user=\"${USER_MAP%%:*}\"\n        local remote_user=\"${USER_MAP##*:}\"\n        SUMMARY_USER_MAP_APPLIED=\"本地'${local_user}' -\u003e 云端'${remote_user}'\"\n        log_info \"模式: 映射同步 (${SUMMARY_USER_MAP_APPLIED})\"\n        if [[ -d \"$ST_DIR/data/$local_user\" ]]; then\n            SUMMARY_USERS_PROCESSED=(\"$local_user\")\n            mkdir -p \"$temp_dir/data/$remote_user\"\n            rsync -aq --delete \"${rsync_exclude_args[@]}\" \"$ST_DIR/data/$local_user/\" \"$temp_dir/data/$remote_user/\"\n        fi\n    else\n        log_info \"模式: 镜像同步 (同步所有本地用户)\"\n        rm -rf \"${temp_dir:?}\"/*\n        local local_users\n        local_users=($(fn_get_user_folders \"$ST_DIR/data\"))\n        SUMMARY_USERS_PROCESSED=(\"${local_users[@]}\")\n        for l_user in \"${local_users[@]}\"; do\n            mkdir -p \"$temp_dir/data/$l_user\"\n            rsync -aq --delete \"${rsync_exclude_args[@]}\" \"$ST_DIR/data/$l_user/\" \"$temp_dir/data/$l_user/\"\n        done\n    fi\n\n    # 步骤 3: 处理配置文件\n    log_info \"步骤 3/5: 处理配置文件...\"\n    if [[ \"$SYNC_CONFIG_YAML\" == \"true\" ]] \u0026\u0026 [[ -f \"$ST_DIR/config.yaml\" ]]; then\n        SUMMARY_CONFIG_SYNCED=\"是\"\n        log_info \"正在同步 config.yaml...\"\n        cp \"$ST_DIR/config.yaml\" \"$temp_dir/config.yaml\"\n    fi\n\n    cd \"$temp_dir\" || exit 1\n    git add .\n\n    # 如果没有文件变动，则提前结束\n    if git diff-index --quiet --cached HEAD --; then\n        fn_export_extension_links\n        fn_print_summary\n        log_info \"数据与云端一致，无需上传。\"\n        return 0\n    fi\n\n    # 步骤 4 \u0026 5: 提交并推送变动\n    log_info \"步骤 4/5: 提交数据变更...\"\n    git commit -m \"来自服务器的数据同步: $(date +'%Y-%m-%d %H:%M:%S')\" -q\n\n    log_info \"步骤 5/5: 推送数据...\"\n    if git push -q; then\n        log_info \"    ${GREEN}[成功] 数据成功推送到云端。${NC}\"\n    else\n        log_error \"使用线路 [${SUMMARY_MIRROR_USED}] 推送失败，请检查Token权限或更换镜像！\"\n    fi\n\n    fn_export_extension_links\n    fn_print_summary\n    log_info \"${GREEN}✓ [成功] 数据已成功上传到云端！${NC}\"\n}\n\n# 执行恢复操作：从远程 Git 仓库恢复数据到本地\nfn_sync_down() {\n    SUMMARY_ACTION_TYPE=\"恢复\"\n    fn_backup_local \"恢复前\"\n    log_info \"开始执行 [${SUMMARY_ACTION_TYPE}] 任务。\"\n    local temp_dir\n    temp_dir=$(mktemp -d)\n    trap 'rm -rf \"$temp_dir\"' EXIT\n\n    # 步骤 1: 下载远程仓库到临时目录\n    local full_mirror_list=(\"https://github.com\")\n    if [[ \"$ENABLE_MIRRORS\" == \"true\" ]]; then\n        full_mirror_list+=(\"${MIRROR_LIST[@]}\")\n    fi\n\n    local clone_success=false\n    for mirror_url in \"${full_mirror_list[@]}\"; do\n        local authed_url\n        authed_url=$(fn_construct_authed_url \"$mirror_url\") || continue\n        local host\n        host=$(echo \"$mirror_url\" | sed -e 's|https://||' -e 's|/.*$||')\n        log_info \"步骤 1/3: 正在尝试使用线路 [${host}] 下载云端数据...\"\n        if git clone -q --depth 1 \"$authed_url\" \"$temp_dir\"; then\n            clone_success=true\n            SUMMARY_MIRROR_USED=\"$host\"\n            log_info \"    ${GREEN}[成功] 下载成功。${NC}\"\n            break\n        else\n            log_warn \"    ${YELLOW}[失败] 使用线路 [${host}] 下载失败，正在切换...${NC}\"\n        fi\n    done\n    if [[ \"$clone_success\" == false ]]; then\n        log_error \"已尝试所有可用线路，但下载云端数据均失败。\"\n    fi\n\n    # 定义 rsync 排除参数\n    local rsync_exclude_args=('--exclude=extensions/' '--exclude=backups/' '--exclude=*.log')\n\n    # 步骤 2: 将临时目录中的数据恢复到本地\n    log_info \"步骤 2/3: 恢复用户数据...\"\n    if [[ -n \"$USER_MAP\" ]] \u0026\u0026 [[ \"$USER_MAP\" == *\":\"* ]]; then\n        local local_user=\"${USER_MAP%%:*}\"\n        local remote_user=\"${USER_MAP##*:}\"\n        SUMMARY_USER_MAP_APPLIED=\"云端'${remote_user}' -\u003e 本地'${local_user}'\"\n        log_info \"模式: 映射同步 (${SUMMARY_USER_MAP_APPLIED})\"\n        if [[ ! -d \"$temp_dir/data/$remote_user\" ]]; then\n            log_error \"在云端仓库中找不到用户文件夹 '$remote_user'！\"\n        fi\n        SUMMARY_USERS_PROCESSED=(\"$remote_user\")\n        mkdir -p \"$ST_DIR/data/$local_user\"\n        rsync -aq --delete \"${rsync_exclude_args[@]}\" \"$temp_dir/data/$remote_user/\" \"$ST_DIR/data/$local_user/\"\n    else\n        log_info \"模式: 镜像同步 (恢复所有云端用户)\"\n        local remote_users_all\n        remote_users_all=($(fn_get_user_folders \"$temp_dir/data\"))\n        local final_remote_users=()\n\n        if [[ -n \"$EXCLUDE_USERS\" ]]; then\n            SUMMARY_EXCLUDES_APPLIED=\"$EXCLUDE_USERS\"\n            log_info \"应用排除规则: 将不会从云端恢复以下用户: $EXCLUDE_USERS\"\n            for r_user in \"${remote_users_all[@]}\"; do\n                if ! [[ \" $EXCLUDE_USERS \" =~ \" $r_user \" ]]; then\n                    final_remote_users+=(\"$r_user\")\n                fi\n            done\n        else\n            final_remote_users=(\"${remote_users_all[@]}\")\n            SUMMARY_EXCLUDES_APPLIED=\"无\"\n        fi\n\n        SUMMARY_USERS_PROCESSED=(\"${final_remote_users[@]}\")\n        # 清理本地存在但远程仓库已不存在的用户\n        local local_users\n        local_users=($(fn_get_user_folders \"$ST_DIR/data\"))\n        for l_user in \"${local_users[@]}\"; do\n            if ! [[ \" ${final_remote_users[*]} \" =~ \" ${l_user} \" ]]; then\n                log_warn \"清理本地多余的用户: $l_user\"\n                rm -rf \"$ST_DIR/data/$l_user\"\n            fi\n        done\n        # 同步远程用户数据到本地\n        for r_user in \"${final_remote_users[@]}\"; do\n            mkdir -p \"$ST_DIR/data/$r_user\"\n            rsync -aq --delete \"${rsync_exclude_args[@]}\" \"$temp_dir/data/$r_user/\" \"$ST_DIR/data/$r_user/\"\n        done\n    fi\n\n    # 步骤 3: 恢复配置文件\n    log_info \"步骤 3/3: 恢复配置文件...\"\n    if [[ \"$SYNC_CONFIG_YAML\" == \"true\" ]] \u0026\u0026 [[ -f \"$temp_dir/config.yaml\" ]]; then\n        SUMMARY_CONFIG_SYNCED=\"是\"\n        log_info \"正在恢复 config.yaml...\"\n        cp \"$temp_dir/config.yaml\" \"$ST_DIR/config.yaml\"\n    fi\n\n    fn_export_extension_links\n    fn_print_summary\n    log_info \"${GREEN}✓ [成功] 数据已从云端恢复到本地！${NC}\"\n}\n\n# --- 主函数入口 ---\nmain() {\n    fn_check_deps\n    fn_setup_paths_and_load_config\n    case \"$ACTION\" in\n        up)\n            fn_sync_up\n            ;;\n        down)\n            fn_sync_down\n            ;;\n        *)\n            log_error \"未知的操作: '${ACTION}'。请检查脚本顶部的 ACTION 变量设置。\"\n            ;;\n    esac\n}\n\n# 执行主函数\nmain\n","command":"","containerName":"","user":"root","url":"","scriptName":"","apps":null,"websites":null,"dbType":"mysql","dbName":null,"exclusionRules":"","isDir":true,"sourceDir":"","retainCopies":20,"retryTimes":0,"timeout":3600,"ignoreErr":false,"snapshotRule":{"withImage":false,"ignoreApps":null},"secret":"","sourceAccounts":null,"downloadAccount":"","alertCount":0,"alertTitle":"","alertMethod":""},{"name":"酒馆GIT【上传】","type":"shell","groupID":7,"specCustom":false,"spec":"30 1 3 * *","executor":"bash","scriptMode":"input","script":"#!/usr/bin/env bash\n\n# SillyTavern 1Panel 同步脚本 v1.0\n# 作者: Qingjue | 小红书号: 826702880\n#\n# 该脚本用于将 SillyTavern 的用户数据与一个远程 Git 仓库进行同步。\n# 支持上传（本地 -\u003e 远程）和恢复（远程 -\u003e 本地）两种模式。\n\n# --- 核心操作定义 ---\n# \"up\"   代表上传本地数据到云端\n# \"down\" 代表从云端恢复数据到本地\nACTION=\"up\"\n\n# --- 脚本基础设置 ---\n# 任何命令执行失败或管道失败时立即退出脚本\nset -e\nset -o pipefail\n\n# --- 全局常量 ---\n# 用于日志输出的颜色代码\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nRED='\\033[0;31m'\nNC='\\033[0m'\nCYAN='\\033[0;36m'\n\n# SillyTavern 顶层系统文件夹，用于在同步时排除\nreadonly TOP_LEVEL_SYSTEM_FOLDERS=(\"data/_storage\" \"data/_cache\" \"data/_uploads\" \"data/_webpack\")\n\n# --- 全局变量 ---\n# 脚本运行时动态填充的变量\nST_DIR=\"\"\nREPO_URL=\"\"\nREPO_TOKEN=\"\"\nSYNC_CONFIG_YAML=\"\"\nUSER_MAP=\"\"\nEXCLUDE_USERS=\"\"\nENABLE_MIRRORS=\"false\"\nMIRROR_LIST=()\n\n# 用于生成任务摘要的变量\nSUMMARY_ACTION_TYPE=\"\"\nSUMMARY_TARGET_REPO=\"\"\nSUMMARY_MIRROR_USED=\"\"\nSUMMARY_USERS_PROCESSED=()\nSUMMARY_CONFIG_SYNCED=\"否\"\nSUMMARY_USER_MAP_APPLIED=\"无\"\nSUMMARY_EXCLUDES_APPLIED=\"无\"\n\n# --- 日志函数 ---\nlog_info() { echo -e \"${GREEN}[信息] $1${NC}\"; }\nlog_warn() { echo -e \"${YELLOW}[警告] $1${NC}\"; }\nlog_error() { echo -e \"\\n${RED}[错误] $1${NC}\\n\"; exit 1; }\n\n# --- 辅助函数 ---\n\n# 获取 SillyTavern/data 目录下的所有非系统用户文件夹\nfn_get_user_folders() {\n    local target_dir=\"$1\"\n    if [[ ! -d \"$target_dir\" ]]; then return; fi\n\n    mapfile -t all_subdirs \u003c \u003c(find \"$target_dir\" -mindepth 1 -maxdepth 1 -type d -exec basename {} \\;)\n    local user_folders=()\n    for dir in \"${all_subdirs[@]}\"; do\n        local is_system_folder=false\n        for sys_folder in \"${TOP_LEVEL_SYSTEM_FOLDERS[@]}\"; do\n            if [[ \"data/$dir\" == \"$sys_folder\" ]]; then\n                is_system_folder=true\n                break\n            fi\n        done\n        if [[ \"$is_system_folder\" == false ]]; then\n            user_folders+=(\"$dir\")\n        fi\n    done\n    echo \"${user_folders[@]}\"\n}\n\n# 自动查找并加载配置文件，同时推导 SillyTavern 的根目录\nfn_setup_paths_and_load_config() {\n    log_info \"正在智能搜索配置文件 (git_sync.conf)...\"\n    local config_file\n    config_file=$(find /root /home /opt -maxdepth 5 -type f -name \"git_sync.conf\" 2\u003e/dev/null | head -n 1)\n    if [[ -z \"$config_file\" ]]; then\n        log_error \"未能找到 'git_sync.conf' 配置文件。\\n请确保在 SillyTavern 项目目录内创建了 '.config/git_sync.conf' 文件。\"\n    fi\n    log_info \"已找到同步配置文件: $config_file\"\n\n    local config_dir\n    config_dir=$(dirname \"$config_file\")\n    ST_DIR=$(dirname \"$config_dir\")\n\n    if [[ ! -d \"$ST_DIR\" ]] || [[ ! -f \"${ST_DIR}/docker-compose.yml\" ]]; then\n        log_error \"根据配置文件推导出的 SillyTavern 目录 '$ST_DIR' 无效。\\n请检查 'git_sync.conf' 的存放位置是否正确。\"\n    fi\n    log_info \"已自动推导 SillyTavern 目录为: ${ST_DIR}\"\n\n    # 加载主配置文件\n    # shellcheck source=/dev/null\n    source \"$config_file\"\n    SUMMARY_TARGET_REPO=\"$REPO_URL\"\n    if [[ -z \"$REPO_URL\" ]] || [[ -z \"$REPO_TOKEN\" ]]; then\n        log_error \"配置文件 'git_sync.conf' 不完整！请确保已设置 REPO_URL 和 REPO_TOKEN。\"\n    fi\n\n    # 加载可选的同步规则和网络配置文件\n    local sync_rules_config=\"${config_dir}/sync_rules.conf\"\n    if [[ -f \"$sync_rules_config\" ]]; then\n        log_info \"已找到同步规则文件: $sync_rules_config\"\n        # shellcheck source=/dev/null\n        source \"$sync_rules_config\"\n    fi\n\n    local network_config=\"${config_dir}/network.conf\"\n    if [[ -f \"$network_config\" ]]; then\n        log_info \"已找到网络配置文件: $network_config\"\n        # shellcheck source=/dev/null\n        source \"$network_config\"\n    fi\n    log_info \"配置加载成功！镜像加速: ${ENABLE_MIRRORS}\"\n}\n\n# 检查脚本运行所需的核心依赖（git, rsync, zip）并尝试自动安装\nfn_check_deps() {\n    log_info \"正在检查核心依赖 (git, rsync, zip)...\"\n    local missing_pkgs=()\n    for pkg in git rsync zip; do\n        if ! command -v \"$pkg\" \u0026\u003e/dev/null; then\n            missing_pkgs+=(\"$pkg\")\n        fi\n    done\n\n    if [[ ${#missing_pkgs[@]} -gt 0 ]]; then\n        log_warn \"检测到核心依赖缺失: ${missing_pkgs[*]}. 正在尝试自动安装...\"\n        if apt-get update -y \u0026\u0026 apt-get install -y \"${missing_pkgs[@]}\"; then\n            log_info \"核心依赖已自动安装成功！\"\n        else\n            log_error \"自动安装依赖失败！\\n请手动执行命令: apt-get update \u0026\u0026 apt-get install -y ${missing_pkgs[*]}\"\n        fi\n    else\n        log_info \"核心依赖完整。\"\n    fi\n}\n\n# 根据镜像地址和仓库地址，构造包含认证信息的 Git URL\nfn_construct_authed_url() {\n    local mirror_base_url=\"$1\"\n    local repo_path\n    repo_path=$(echo \"$REPO_URL\" | sed 's|https://github.com/||')\n\n    case \"$mirror_base_url\" in\n        *\"github.com\"*)\n            echo \"https://${REPO_TOKEN}@github.com/${repo_path}\" ;;\n        *\"hub.gitmirror.com\"*)\n            echo \"https://${REPO_TOKEN}@hub.gitmirror.com/${repo_path}\" ;;\n        *\"/gh\")\n            local domain\n            domain=$(echo \"$mirror_base_url\" | sed -e 's|https://||' -e 's|/.*$||')\n            echo \"https://${REPO_TOKEN}@${domain}/gh/${repo_path}\" ;;\n        *\"gh-proxy.com\"*|*\"gh.llkk.cc\"*|*\"tvv.tw\"*|*\"proxy.pipers.cn\"*|*\"gh.catmak.name\"*|*\"gh-proxy.net\"*)\n            echo \"${mirror_base_url}/https://${REPO_TOKEN}@github.com/${repo_path}\" ;;\n        *)\n            return 1 ;;\n    esac\n}\n\n# 扫描并输出所有已安装的全局扩展和用户扩展的 Git 仓库地址\nfn_export_extension_links() {\n    local all_links_output=\"\"\n    local global_ext_path=\"$ST_DIR/public/scripts/extensions/third-party\"\n\n    if [[ -d \"$global_ext_path\" ]]; then\n        local global_links\n        global_links=$(\n            find \"$global_ext_path\" -mindepth 1 -maxdepth 1 -type d | while read -r ext_dir; do\n                if [[ -d \"$ext_dir/.git\" ]]; then\n                    git -C \"$ext_dir\" config --get remote.origin.url 2\u003e/dev/null\n                fi\n            done\n        )\n        if [[ -n \"$global_links\" ]]; then\n            all_links_output+=\"═══ 全局扩展 ═══\\n${global_links}\\n\"\n        fi\n    fi\n\n    local user_folders\n    user_folders=($(fn_get_user_folders \"$ST_DIR/data\"))\n    for user in \"${user_folders[@]}\"; do\n        local user_ext_path=\"$ST_DIR/data/$user/extensions\"\n        if [[ -d \"$user_ext_path\" ]]; then\n            local user_links\n            user_links=$(\n                find \"$user_ext_path\" -mindepth 1 -maxdepth 1 -type d | while read -r ext_dir; do\n                    if [[ -d \"$ext_dir/.git\" ]]; then\n                        git -C \"$ext_dir\" config --get remote.origin.url 2\u003e/dev/null\n                    fi\n                done\n            )\n            if [[ -n \"$user_links\" ]]; then\n                all_links_output+=\"\\n═══ 用户 [${user}] 的扩展 ═══\\n${user_links}\"\n            fi\n        fi\n    done\n\n    if [[ -n \"$all_links_output\" ]]; then\n        echo -e \"${CYAN}─────────────────── 已安装扩展链接 ───────────────────${NC}\"\n        printf \"%b\" \"${CYAN}${all_links_output}${NC}\\n\"\n        echo -e \"${CYAN}──────────────────────────────────────────────────────${NC}\"\n    fi\n}\n\n# 在任务结束时打印本次同步的摘要信息\nfn_print_summary() {\n    echo -e \"${CYAN}──────────────────── 同步任务摘要 ────────────────────${NC}\"\n    echo -e \"${CYAN}任务类型        : ${SUMMARY_ACTION_TYPE}${NC}\"\n    echo -e \"${CYAN}目标仓库        : ${SUMMARY_TARGET_REPO}${NC}\"\n    echo -e \"${CYAN}实际使用线路    : ${SUMMARY_MIRROR_USED}${NC}\"\n    echo -e \"${CYAN}──────────────────────────────────────────────────────${NC}\"\n    if [[ ${#SUMMARY_USERS_PROCESSED[@]} -gt 0 ]]; then\n        echo -e \"${CYAN}同步的用户文件夹: ${SUMMARY_USERS_PROCESSED[*]}${NC}\"\n    else\n        echo -e \"${CYAN}同步的用户文件夹: 无${NC}\"\n    fi\n    echo -e \"${CYAN}同步 config.yaml  : ${SUMMARY_CONFIG_SYNCED}${NC}\"\n    echo -e \"${CYAN}────────────────────── 应用规则 ──────────────────────${NC}\"\n    echo -e \"${CYAN}用户映射规则    : ${SUMMARY_USER_MAP_APPLIED}${NC}\"\n    if [[ \"$SUMMARY_ACTION_TYPE\" == \"恢复\" ]]; then\n      echo -e \"${CYAN}排除的云端用户  : ${SUMMARY_EXCLUDES_APPLIED}${NC}\"\n    fi\n    echo -e \"${CYAN}──────────────────────────────────────────────────────${NC}\"\n}\n\n# 创建一个本地的用户数据备份压缩包\nfn_backup_local() {\n    local backup_type=\"$1\"\n    local backup_root_dir=\"${ST_DIR}/_SillyTavern_Backups\"\n    mkdir -p \"$backup_root_dir\"\n    log_info \"正在触发“${backup_type}”类型的本地备份...\"\n\n    local timestamp\n    timestamp=$(date +\"%Y-%m-%d_%H-%M\")\n    local backup_zip_path=\"${backup_root_dir}/ST_备份_${backup_type}_${timestamp}.zip\"\n\n    local paths_to_zip=()\n    local user_folders\n    user_folders=($(fn_get_user_folders \"$ST_DIR/data\"))\n    for user in \"${user_folders[@]}\"; do\n        paths_to_zip+=(\"data/$user\")\n    done\n\n    if [[ \"$SYNC_CONFIG_YAML\" == \"true\" ]] \u0026\u0026 [[ -f \"$ST_DIR/config.yaml\" ]]; then\n        paths_to_zip+=(\"config.yaml\")\n    fi\n\n    if [[ ${#paths_to_zip[@]} -eq 0 ]]; then\n        log_warn \"未找到任何可备份的用户数据，已跳过本地备份。\"\n        return\n    fi\n\n    log_info \"正在压缩文件到: ${backup_zip_path}\"\n    # 在 ST_DIR 目录内执行 zip 命令，以保持压缩包内的目录结构正确\n    if (cd \"$ST_DIR\" \u0026\u0026 zip -rq \"$backup_zip_path\" \"${paths_to_zip[@]}\" --exclude \"*/extensions/*\" --exclude \"*/backups/*\" --exclude \"*.log\"); then\n        log_info \"创建本地备份成功。\"\n    else\n        log_error \"创建本地备份失败！\"\n    fi\n}\n\n# --- 核心同步逻辑 ---\n\n# 执行上传操作：将本地数据同步到远程 Git 仓库\nfn_sync_up() {\n    SUMMARY_ACTION_TYPE=\"上传\"\n    log_info \"开始执行 [${SUMMARY_ACTION_TYPE}] 任务。\"\n    local temp_dir\n    temp_dir=$(mktemp -d)\n    trap 'rm -rf \"$temp_dir\"' EXIT\n\n    # 步骤 1: 克隆远程仓库到临时目录\n    local full_mirror_list=(\"https://github.com\")\n    if [[ \"$ENABLE_MIRRORS\" == \"true\" ]]; then\n        full_mirror_list+=(\"${MIRROR_LIST[@]}\")\n    fi\n\n    local clone_success=false\n    for mirror_url in \"${full_mirror_list[@]}\"; do\n        local authed_clone_url\n        authed_clone_url=$(fn_construct_authed_url \"$mirror_url\") || continue\n        local host\n        host=$(echo \"$mirror_url\" | sed -e 's|https://||' -e 's|/.*$||')\n        log_info \"步骤 1/5: 正在尝试使用线路 [${host}] 克隆仓库...\"\n        if git clone -q --depth 1 \"$authed_clone_url\" \"$temp_dir\"; then\n            clone_success=true\n            SUMMARY_MIRROR_USED=\"$host\"\n            log_info \"    ${GREEN}[成功] 克隆成功。${NC}\"\n            break\n        else\n            log_warn \"    ${YELLOW}[失败] 使用线路 [${host}] 克隆失败，正在切换...${NC}\"\n        fi\n    done\n    if [[ \"$clone_success\" == false ]]; then\n        log_error \"已尝试所有可用线路，但克隆云端仓库均失败。\"\n    fi\n\n    # 定义 rsync 排除参数，使用数组以避免参数分割问题\n    local rsync_exclude_args=('--exclude=extensions/' '--exclude=backups/' '--exclude=*.log')\n\n    # 步骤 2: 将本地数据同步到临时目录\n    log_info \"步骤 2/5: 同步本地用户数据...\"\n    if [[ -n \"$USER_MAP\" ]] \u0026\u0026 [[ \"$USER_MAP\" == *\":\"* ]]; then\n        local local_user=\"${USER_MAP%%:*}\"\n        local remote_user=\"${USER_MAP##*:}\"\n        SUMMARY_USER_MAP_APPLIED=\"本地'${local_user}' -\u003e 云端'${remote_user}'\"\n        log_info \"模式: 映射同步 (${SUMMARY_USER_MAP_APPLIED})\"\n        if [[ -d \"$ST_DIR/data/$local_user\" ]]; then\n            SUMMARY_USERS_PROCESSED=(\"$local_user\")\n            mkdir -p \"$temp_dir/data/$remote_user\"\n            rsync -aq --delete \"${rsync_exclude_args[@]}\" \"$ST_DIR/data/$local_user/\" \"$temp_dir/data/$remote_user/\"\n        fi\n    else\n        log_info \"模式: 镜像同步 (同步所有本地用户)\"\n        rm -rf \"${temp_dir:?}\"/*\n        local local_users\n        local_users=($(fn_get_user_folders \"$ST_DIR/data\"))\n        SUMMARY_USERS_PROCESSED=(\"${local_users[@]}\")\n        for l_user in \"${local_users[@]}\"; do\n            mkdir -p \"$temp_dir/data/$l_user\"\n            rsync -aq --delete \"${rsync_exclude_args[@]}\" \"$ST_DIR/data/$l_user/\" \"$temp_dir/data/$l_user/\"\n        done\n    fi\n\n    # 步骤 3: 处理配置文件\n    log_info \"步骤 3/5: 处理配置文件...\"\n    if [[ \"$SYNC_CONFIG_YAML\" == \"true\" ]] \u0026\u0026 [[ -f \"$ST_DIR/config.yaml\" ]]; then\n        SUMMARY_CONFIG_SYNCED=\"是\"\n        log_info \"正在同步 config.yaml...\"\n        cp \"$ST_DIR/config.yaml\" \"$temp_dir/config.yaml\"\n    fi\n\n    cd \"$temp_dir\" || exit 1\n    git add .\n\n    # 如果没有文件变动，则提前结束\n    if git diff-index --quiet --cached HEAD --; then\n        fn_export_extension_links\n        fn_print_summary\n        log_info \"数据与云端一致，无需上传。\"\n        return 0\n    fi\n\n    # 步骤 4 \u0026 5: 提交并推送变动\n    log_info \"步骤 4/5: 提交数据变更...\"\n    git commit -m \"来自服务器的数据同步: $(date +'%Y-%m-%d %H:%M:%S')\" -q\n\n    log_info \"步骤 5/5: 推送数据...\"\n    if git push -q; then\n        log_info \"    ${GREEN}[成功] 数据成功推送到云端。${NC}\"\n    else\n        log_error \"使用线路 [${SUMMARY_MIRROR_USED}] 推送失败，请检查Token权限或更换镜像！\"\n    fi\n\n    fn_export_extension_links\n    fn_print_summary\n    log_info \"${GREEN}✓ [成功] 数据已成功上传到云端！${NC}\"\n}\n\n# 执行恢复操作：从远程 Git 仓库恢复数据到本地\nfn_sync_down() {\n    SUMMARY_ACTION_TYPE=\"恢复\"\n    fn_backup_local \"恢复前\"\n    log_info \"开始执行 [${SUMMARY_ACTION_TYPE}] 任务。\"\n    local temp_dir\n    temp_dir=$(mktemp -d)\n    trap 'rm -rf \"$temp_dir\"' EXIT\n\n    # 步骤 1: 下载远程仓库到临时目录\n    local full_mirror_list=(\"https://github.com\")\n    if [[ \"$ENABLE_MIRRORS\" == \"true\" ]]; then\n        full_mirror_list+=(\"${MIRROR_LIST[@]}\")\n    fi\n\n    local clone_success=false\n    for mirror_url in \"${full_mirror_list[@]}\"; do\n        local authed_url\n        authed_url=$(fn_construct_authed_url \"$mirror_url\") || continue\n        local host\n        host=$(echo \"$mirror_url\" | sed -e 's|https://||' -e 's|/.*$||')\n        log_info \"步骤 1/3: 正在尝试使用线路 [${host}] 下载云端数据...\"\n        if git clone -q --depth 1 \"$authed_url\" \"$temp_dir\"; then\n            clone_success=true\n            SUMMARY_MIRROR_USED=\"$host\"\n            log_info \"    ${GREEN}[成功] 下载成功。${NC}\"\n            break\n        else\n            log_warn \"    ${YELLOW}[失败] 使用线路 [${host}] 下载失败，正在切换...${NC}\"\n        fi\n    done\n    if [[ \"$clone_success\" == false ]]; then\n        log_error \"已尝试所有可用线路，但下载云端数据均失败。\"\n    fi\n\n    # 定义 rsync 排除参数\n    local rsync_exclude_args=('--exclude=extensions/' '--exclude=backups/' '--exclude=*.log')\n\n    # 步骤 2: 将临时目录中的数据恢复到本地\n    log_info \"步骤 2/3: 恢复用户数据...\"\n    if [[ -n \"$USER_MAP\" ]] \u0026\u0026 [[ \"$USER_MAP\" == *\":\"* ]]; then\n        local local_user=\"${USER_MAP%%:*}\"\n        local remote_user=\"${USER_MAP##*:}\"\n        SUMMARY_USER_MAP_APPLIED=\"云端'${remote_user}' -\u003e 本地'${local_user}'\"\n        log_info \"模式: 映射同步 (${SUMMARY_USER_MAP_APPLIED})\"\n        if [[ ! -d \"$temp_dir/data/$remote_user\" ]]; then\n            log_error \"在云端仓库中找不到用户文件夹 '$remote_user'！\"\n        fi\n        SUMMARY_USERS_PROCESSED=(\"$remote_user\")\n        mkdir -p \"$ST_DIR/data/$local_user\"\n        rsync -aq --delete \"${rsync_exclude_args[@]}\" \"$temp_dir/data/$remote_user/\" \"$ST_DIR/data/$local_user/\"\n    else\n        log_info \"模式: 镜像同步 (恢复所有云端用户)\"\n        local remote_users_all\n        remote_users_all=($(fn_get_user_folders \"$temp_dir/data\"))\n        local final_remote_users=()\n\n        if [[ -n \"$EXCLUDE_USERS\" ]]; then\n            SUMMARY_EXCLUDES_APPLIED=\"$EXCLUDE_USERS\"\n            log_info \"应用排除规则: 将不会从云端恢复以下用户: $EXCLUDE_USERS\"\n            for r_user in \"${remote_users_all[@]}\"; do\n                if ! [[ \" $EXCLUDE_USERS \" =~ \" $r_user \" ]]; then\n                    final_remote_users+=(\"$r_user\")\n                fi\n            done\n        else\n            final_remote_users=(\"${remote_users_all[@]}\")\n            SUMMARY_EXCLUDES_APPLIED=\"无\"\n        fi\n\n        SUMMARY_USERS_PROCESSED=(\"${final_remote_users[@]}\")\n        # 清理本地存在但远程仓库已不存在的用户\n        local local_users\n        local_users=($(fn_get_user_folders \"$ST_DIR/data\"))\n        for l_user in \"${local_users[@]}\"; do\n            if ! [[ \" ${final_remote_users[*]} \" =~ \" ${l_user} \" ]]; then\n                log_warn \"清理本地多余的用户: $l_user\"\n                rm -rf \"$ST_DIR/data/$l_user\"\n            fi\n        done\n        # 同步远程用户数据到本地\n        for r_user in \"${final_remote_users[@]}\"; do\n            mkdir -p \"$ST_DIR/data/$r_user\"\n            rsync -aq --delete \"${rsync_exclude_args[@]}\" \"$temp_dir/data/$r_user/\" \"$ST_DIR/data/$r_user/\"\n        done\n    fi\n\n    # 步骤 3: 恢复配置文件\n    log_info \"步骤 3/3: 恢复配置文件...\"\n    if [[ \"$SYNC_CONFIG_YAML\" == \"true\" ]] \u0026\u0026 [[ -f \"$temp_dir/config.yaml\" ]]; then\n        SUMMARY_CONFIG_SYNCED=\"是\"\n        log_info \"正在恢复 config.yaml...\"\n        cp \"$temp_dir/config.yaml\" \"$ST_DIR/config.yaml\"\n    fi\n\n    fn_export_extension_links\n    fn_print_summary\n    log_info \"${GREEN}✓ [成功] 数据已从云端恢复到本地！${NC}\"\n}\n\n# --- 主函数入口 ---\nmain() {\n    fn_check_deps\n    fn_setup_paths_and_load_config\n    case \"$ACTION\" in\n        up)\n            fn_sync_up\n            ;;\n        down)\n            fn_sync_down\n            ;;\n        *)\n            log_error \"未知的操作: '${ACTION}'。请检查脚本顶部的 ACTION 变量设置。\"\n            ;;\n    esac\n}\n\n# 执行主函数\nmain\n","command":"","containerName":"","user":"root","url":"","scriptName":"","apps":null,"websites":null,"dbType":"mysql","dbName":null,"exclusionRules":"","isDir":true,"sourceDir":"","retainCopies":20,"retryTimes":0,"timeout":3600,"ignoreErr":false,"snapshotRule":{"withImage":false,"ignoreApps":null},"secret":"","sourceAccounts":null,"downloadAccount":"","alertCount":0,"alertTitle":"","alertMethod":""}]